%lex
/* Those are helper groups */
NL [\n]
identifier [a-zA-Z_][0-9a-zA-Z_]*

exponent_part [eE][-+]?[0-9]+
fractional_constant ([0-9]*"."[0-9]+)|([0-9]+".")
floating_constant (({fractional_constant}{exponent_part}?)|([0-9]+{exponent_part}))[FfLl]?

integer_suffix_opt ([uU]?[lL]{0,2})|([lL]{1,2}[uU])
decimal_constant [1-9][0-9]*{integer_suffix_opt}
octal_constant "0"[0-7]*{integer_suffix_opt}
hex_constant "0"[xX][0-9a-fA-F]+{integer_suffix_opt}

simple_escape [abfnrtv'"?\\]
octal_escape  [0-7]{1,3}
hex_escape "x"[0-9a-fA-F]+

escape_sequence [\\]({simple_escape}|{octal_escape}|{hex_escape})
c_char [^'\\\n]|{escape_sequence}
s_char [^"\\\n]|{escape_sequence}

h_tab [\011]
form_feed [\014]
v_tab [\013]
c_return [\015]

horizontal_white [ ]|{h_tab}

%s typedef_mode
%x PREPR
%x WRAP_PREP
%x CPP_COMMENT
%x C_COMMENT

%%
/* lex.digraph */
/* is this realy necessary? */
"<%"						return "{"
"%>"						return "}"
"<:"						return "["
":>"						return "]"
"%:"						return "#"
"%:%:"					return "##"
"and"						return "AND"
"bitor"					return "|"
"or"						return "OR"
"xor"						return "^"
"compl"					return "~"
"bitand"				return "&"
"and_eq"				return "ANDassign"
"or_eq"					return "ORassign"
"xor_eq"				return "XORassign"
"not"						return "!"
"not_eq"				return "NE"

/* lex.token */

/* lex.token.keyword */
"alignas"				return "ALIGNAS"
"alignof"				return "ALIGNOF"
"asm"						return "ASM"
"auto"					return "AUTO"
"bool"					return "BOOL"
"break"					return "BREAK"
"case"					return "CASE"
"catch"					return "CATCH"
"char"					return "CHAR"
"char16_t"			return "CHAR16_T"
"char32_t"			return "CHAR32_T"
"class"					return "CLASS"
"const"					return "CONST"
"constexpr"			return "CONSTEXPR"
"const_cast"		return "CONST_CAST"
"continue"			return "CONTINUE"
"decltype"			return "DECLTYPE"
"default"				return "DEFAULT"
"delete"				return "DELETE"
"do"						return "DO"
"double"				return "DOUBLE"
"dynamic_cast"	return "DYNAMIC_CAST"
"else"					return "ELSE"
"enum"					return "ENUM"
"explicit"			return "EXPLICIT"
"export"				return "EXPORT"
"extern"				return "EXTERN"
"false"					return "FALSE"
"float"					return "FLOAT"
"for"						return "FOR"
"friend"				return "FRIEND"
"goto"					return "GOTO"
"if"						return "IF"
"inline"				return "INLINE"
"int"						return "INT"
"long"					return "LONG"
"mutable"				return "MUTABLE"
"namespace"			return "NAMESPACE"
"new"						return "NEW"
"noexcept"			return "NOEXCEPT"
"nullptr"				return "NULLPTR"
"operator"			return "OPERATOR"
"private"				return "PRIVATE"
"protected"			return "PROTECTED"
"public"				return "PUBLIC"
"register"			return "REGISTER"
"reinterpret_cast"	return "REINTERPRET_CAST"
"return"				return "RETURN"
"short"					return "SHORT"
"signed"				return "SIGNED"
"sizeof"				return "SIZEOF"
"static"				return "STATIC"
"static_assert"	return "STATIC_ASSERT"
"static_cast"		return "STATIC_CAST"
"struct"				return "STRUCT"
"switch"				return "SWITCH"
"template"			return "TEMPLATE"
"this"					return "THIS"
"thread_local"	return "THREAD_LOCAL"
"throw"					return "THROW"
"true"					return "TRUE"
"try"						return "TRY"
"typedef"				return "TYPEDEF"
"typeid"				return "TYPEID"
"typename"			return "TYPENAME"
"union"					return "UNION"
"unsigned"			return "UNSIGNED"
"using"					return "USING"
"virtual"				return "VIRTUAL"
"void"					return "VOID"
"volatile"			return "VOLATILE"
"wchar_t"				return "WCHAR_T"
"while"					return "WHILE"

/* lex.token.identifier */
{identifier}		return "IDENTIFIER"

/* lex.token.literal */
{decimal_constant}				return "DECIMAL_LITERAL"
{octal_constant}					return "OCTAL_LITERAL"
{hex_constant}						return "HEXADECIMAL_LITERAL"
{floating_constant}				return "FLOATING_LITERAL"

"L"?['](uUL|"u8")?{c_char}+[']	return "CHARACTER_LITERAL"
"L"?["]{s_char}*["]				return "STRING_LITERAL"

/* lex.token.operator */

/* preprocessing-op-or-punc */
"{"						return '{'
"}"						return '}'
"["						return '['
"]"						return ']'
"#"						return '#'
"##"					return '##'
"("						return '('
")"						return ')'
";"						return ';'
":"						return ':'
"..."					return 'ELLIPSIS'
"?"						return '?'
"::"					return 'CLCL'
"."						return '.'
".*"					return 'DOTSTAR'
'+'						return '+'
'-'						return '-'
'*'						return '*'
'/'						return '/'
'%'						return '%'
'^'						return '^'
'&'						return '&'
'|'						return '|'
'~'						return '~'
'!'						return '!'
'!'						return '!'
'='						return '='
'<'						return '<'
'>'						return '>'
'+='					return 'ADDassign'
'-='					return 'SUBassign'
'*='					return 'MULTassign'
'/='					return 'ADDassign'
'%='					return 'MODassign'
'^='					return 'ERassign'
'&='					return 'ANDassign'
'|='					return 'ORassign'
'<<'					return 'LS'
'>>'					return 'RS'
'<<='					return 'LSassign'
'>>='					return 'RSassign'
'=='					return 'EQ'
'!='					return 'NE'
'<='					return 'LE'
'>='					return 'GE'
'&&'					return 'ANDAND'
'||'					return 'OROR'
'++'					return 'INC'
'--'					return 'DEC'
","						return ','
"->*"					return 'ARROWstar'
"->"					return 'ARROW'



/* lex.token.punctuator */

/* lex.ext not supported currently, no used-defined-literals */

/* lex.preprocessor */
<PREPR>{NL}												%{ this.begin("INITIAL"); return "PP_NEWLINE";%}
<PREPR>\\													this.begin("WRAP_PREP")
<PREPR>({horizontal_white})				{ }
<PREPR>({horizontal_white})*"("		return "PP_LPAREN"

<PREPR>["]												return "PP_QUOTE"
<PREPR>"include"									return "PP_INCLUDE"
<PREPR>"undef"										return "PP_UNDEF"
<PREPR>"line"											return "PP_LINE"
<PREPR>"pragma"										return "PP_PRAGMA"
<PREPR>"define"  									return "PP_DEFINE"
<PREPR>"defined"									return "PP_DEFINED"
<PREPR>"ifdef"										return "PP_IFDEF"
<PREPR>"ifndef"										return "PP_IFNDEF"
<PREPR>"if"												return "PP_IF"
<PREPR>"else"											return "PP_ELSE"
<PREPR>"endif"										return "PP_ENDIF"
<PREPR>"elif"											return "PP_ELIF"
<PREPR>{identifier}								return "IDENTIFIER"
<PREPR>{decimal_constant}					return "DECIMAL_LITERAL"
<PREPR>{octal_constant}						return "OCTAL_LITERAL"
<PREPR>{hex_constant}							return "HEXADECIMAL_LITERAL"
<PREPR>{floating_constant}				return "FLOATING_LITERAL"
<PREPR>"L"?[']{c_char}+[']				return "CHARACTER_LITERAL"
<PREPR>"L"?["]{s_char}*["]				return "STRING_LITERAL"
<PREPR>["][^\n]*["]								return "PP_QCHARSEQUENCE"
<PREPR>"<"[^\n]*">"								return "PP_HCHARSEQUENCE"
<PREPR>.													return "PP_ANYCHAR"

<WRAP_PREP>\n											this.begin("PREPR")
<WRAP_PREP>{identifier}						return "IDENTIFIER"
<CPP_COMMENT>\n 									this.begin("INITIAL")
<CPP_COMMENT>.										return("")
<C_COMMENT>"*/"										this.begin("INITIAL")
<C_COMMENT>.											return("")

/lex



/*	EBNF Grammar does not need tokens like typical bison grammar.
		This allows us to use the 'symbols' directly from the parser.
 */
%ebnf

%start translation_unit

%%
/* literals
	There are several kinds of literals.
		integer_literal
		character_literal
		floating_literal
		string_literal
		boolean_literal
		pointer_literal
		user_defined_literal
*/
integer_literal:
			DECIMAL_LITERAL
			|OCTAL_LITERAL
			|HEXADECIMAL_LITERAL
			;

floating_literal:
			FLOATING_LITERAL
			;

string_literal:
			STRING_LITERAL
			;

character_literal:
			CHARACTER_LITERAL
			;

boolean_literal:
			TRUE
			|FALSE
			;

pointer_literal:
			NULLPTR
			;

identifier:
			IDENTIFIER
			;

/* basic.link */
translation_unit:
			declaration_seq?
			;

/* expr.prim.general */
primary_expression:
			literal
			|THIS
			|'(' expression ')'
			|id_expression
			|lambda_expression
			;

id_expression:
			unqualified_id
			|qualified_id
			;

unqualified_id:
			identifier
			|operator_function_id
			|conversion_function_id
			|literal_operator_id
			|'~' class_name
			|'~' decltype_specifier
			|template_id
			;

qualified_id:
			CLCL? nested_name_specifier TEMPLATE? unqualified_id
			|CLCL identifier
			|CLCL operator_function_id
			|CLCL literal_operator_id
			|CLCL template_id
			;

nested_name_specifier:
			type_name CLCL
			|namespace_name CLCL
			|decltype_specifier CLCL
			|nested_name_specifier identifier CLCL
			|nested_name_specifier TEMPLATE? simple_template_id CLCL
			;

/* expr.prim.lambda */
lambda_expression:
			lambda_introducer lambda_declarator? compound_statement
			;

lambda_introducer:
			'[' lambda_capture? ']'
			;

lambda_capture:
			capture_default
			|capture_list
			|capture_default ',' capture_list
			;

capture_default:
			'&'
			|'='
			;

capture_list:
			capture ELLIPSIS?
			|capture_list ',' ELLIPSIS?
			;

capture:
			identifier
			|'&' identifier
			|THIS
			;

lambda_declarator:
			'(' parameter_declaration_cause ')' MUTABLE? exception_specification? attribute_specifier_seq? trailing_return_type?
			;

/* expr.post */
postfix_expression:
			primary_expression
			|postfix_expression '[' expression ']'
			|postfix_expression '[' braced_init_list? ']'
			|postfix_expression '(' expression_list? ')'
			|simple_type_specifier '(' expresion_list? ')'
			|typename_specifier '(' expression_list? ')'
			|simple_type_specifier braced_init_list
			|typename_specifier braced_init_list
			|postfix_expression '.' TEMPLATE? id_expression
			|postfix_expression ARROW TEMPLATE? id_expression
			|postfix_expression '.' pseudo_destructor_name
			|postfix_expression ARROW pseudo_destructor_name
			|postfix_expression INC
			|postfix_expression DEC
			|DYNAMIC_CAST '<' type_id '>' '(' expression ')'
			|STATIC_CAST '<' type_id '>' '(' expression ')'
			|REINTERPRET_CAST '<' type_id '>' '(' expression ')'
			|CONST_CAST '<' type_id '>' '(' expression ')'
			|TYPEID '(' expression ')'
			|TYPEID '(' type_id ')'
			;

expression_list:
			initializer_list
			;

pseudo_destructor_name:
			CLCL? nested_name_specifier? type_name CLCL '~' type_name
			|CLCL? nested_name_specifier TEMPLATE simple_template_id CLCL '~' type_name
			|CLCL? nested_name_specifier? '~' type_name
			|'~' decltype_specifier
			;

/* expr.unary */
unary_expression:
			postfix_expression
			|INC cast_expression
			|DEC cast_expression
			|unary_operator cast_expression
			|SIZEOF unary_expression
			|SIZEOF '(' type_id ')'
			|SIZEOF ELLIPSIS '(' identifier ')'
			|ALIGNOF '(' type_id ')'
			|noexcept_expression
			|new_expression
			|delete_expression
			;

unary_operator:
			'*'
			|'&'
			|'+'
			|'-'
			|'!'
			|'~'
			;

/* expr.cond */
conditional_expression:
			logical_or_expression
			|logical_or_expression '?' expression ':' assignment_expression
			;

/* expr.ass */
assignment_expression:
			conditional_expression
			|logical_or_expression assignment_operator initializer_clause
			|throw_expression
			;

assignment_operator:
			'='
			|MULTassign
			|DIVassign
			|MODassign
			|ADDassign
			|SUBassign
			|RSassign
			|LSassign
			|ANDassign
			|ERassign
			|ORassign
			;

/* expr.comma */
expression:
			assignment_expression
			|expression ',' assignment_expression
			;

/* expr.const */
constant_expression:
			conditional_expression
			;

/*stmt.stmt */
statement:
			labeled_statement
			|attribute_specifier_seq? expression_statement
			|attribute_specifier_seq? compound_statement
			|attribute_specifier_seq? selection_statement
			|attribute_specifier_seq? iteration_statement
			|attribute_specifier_seq? jump_statement
			|declaration_statement
			|attribute_specifier_seq? try_block
			;

/* stmt.label */

/* stmt.expr */
expression_statement:
			expression? ';'
			;

/* stmt.block */
compound_statement:
			'{' statement_seq? '}'
			;

statement_seq:
			statement
			|statement_seq statement
			;

/* stmt.select */
/* stmt.iter */

/* stmt.jump */
jump_statement:
			BREAK ';'
			|CONTINUE ';'
			|RETURN expression? ';'
			|RETURN braced_init_list? ';'
			|GOTO identifier ';'
			;

/* stmt.dcl */
declaration_statement:
			block_declaration
			;

/* dcl.dcl */
declaration_seq:
			declaration
			|declaration_seq declaration
			;

declaration:
			block_declaration
			|function_definition
			|template_declaration
			|explicit_instantiation
			|explicit_specialization
			|linkage_specification
			|namespace_definition
			|empty_declaration
			|attribute_declaration
			;

block_declaration:
			simple_declaration
			|asm_definition
			|namespace_alias_definition
			|using_declaration
			|using_directive
			|static_assert_declaration
			|alias_declaration
			|opague_enum_declaration
			;

alias_declaration:
			USING identifier '=' type_id ';'
			;

simple_declaration:
			attribute_specifier_seq? decl_specifier_seq? init_declarator_list? ';'
			;

static_assert_declaration:
			STATIC_ASSERT '(' constant_expression ',' string_literal ')' ';'
			;

empty_declaration:
			';'
			;

attribute_declaration:
			attribute_specifier_seq ';'
			;

/* dcl.spec */
decl_specifier:
			storage_class_specifier
			|type_specifier
			|function_specifier
			|FRIEND
			|TYPEDEF
			|CONSTEXPR
			;

decl_specifier_seq:
			decl_specifier attribute_specifier_seq?
			|decl_specifier decl_specifier_seq
			;

/* dcl.stc */
storage_class_specifier:
			REGISTER
			|STATIC
			|THREAD_LOCAL
			|EXTERN
			|MUTABLE
			;

/* dcl.fct.spec */
function_specifier:
			INLINE
			|VIRTUAL
			|EXPLICIT
			;

/* dcl.typedef */
typedef_name:
			identifier
			;

/* dcl.type */
type_specifier:
			trailing_type_specifier
			|class_specifier
			|enum_specifier
			;

trailing_type_specifier:
			simple_type_specifier
			|elaborated_type_specifier
			|typename_specifier
			|cv_qualifier
			;

type_specifier_seq:
			type_specifier attribute_specifier_seq?
			type_specifier type_specifier_seq
			;

trailing_type_specifier_seq:
			trailing_type_specifier attribute_specifier_seq?
			|trailing_type_specifier trailing_type_specifier_seq
			;

/* dct.type.simple */
simple_type_specifier:
			CLCL? nested_name_specifier? type_name
			|CLCL? nested_name_specifier TEMPLATE simple_template_id
			|CHAR
			|"CHAR16_T"
			|"CHAR32_T"
			|WCHAR_T
			|BOOL
			|SHORT
			|INT
			|LONG
			|SIGNED
			|UNSIGNED
			|FLOAT
			|DOUBLE
			|VOID
			|AUTO
			|decltype_specifier
			;

type_name:
			class_name
			|enum_name
			|typedef_name
			|simple_template_id
			;

decltype_specifier:
			DECLTYPE '(' expression ')'
			;

/* dcl.type.elab */
/* dcl.enum */
/* namespace.def */
/* namespace.alias */
/* namespace.udecl */
/* namespace.udir */

/* dcl.asm */
asm_definition:
			ASM '(' string_literal ')' ';'
			;

/* dcl.link */
/* dcl.attr.grammar */

/* dcl.decl */
init_declarator_list:
			init_declarator
			|init_declarator_list ',' init_declarator
			;

init_declarator:
			declarator initializer?
			;

declarator:
			ptr_declarator
			|noptr_declarator parameters_and_qualifiers trailing_return_type
			;

ptr_declarator:
			noptr_declarator
			ptr_operator ptr_declarator
			;

noptr_declarator:
			declarator_id attribute_specifier_seq?
			|noptr_declarator parameters_and_qualifiers
			|noptr_declarator '[' constant_expression? ']' attribute_specifier_seq?
			|'(' ptr_declarator ')'
			;

parameters_and_qualifiers:
			'(' parameter_declaration_clause ')' attribute_specifier_seq? cv_qualifier_seq? ref_qualifier? exception_specification?
			;

trailing_return_type:
			ARROW trailing_type_specifier_seq abstract_declarator?
			;

ptr_operator:
			'*' attribute_specifier_seq? cv_qualifier_seq?
			|'&' attribute_specifier_seq?
			|ANDAND attribute_specifier_seq?
			|CLCL? nested_name_specifier '*' attribute_specifier_seq? cv_qualifier_seq?
			;

cv_qualifier_seq:
			cv_qualifier
			|cv_qualifier cv_qualifier_seq
			;

cv_qualifier:
			CONST
			|VOLATILE
			;

ref_qualifier:
			'&'
			|ANDAND
			;

declarator_id:
			ELLIPSIS? id_expression
			|ELLIPSIS? nested_name_specifier? class_name
			;

/* dcl.name */
/* dcl.fct */
/* dcl.fct.def.general */

/* dcl.init */
initializer:
			brace_or_equal_initializer
			|'(' expression_list ')'
			;

brace_or_equal_initializer:
			'=' initializer_clause
			|braced_init_list
			;

initializer_clause:
			assignment_expression
			|braced_init_list
			;

initializer_list:
			initializer_clause ELLIPSIS?
			|initializer_list ',' initializer_clause ELLIPSIS?
			;

braced_init_list:
			'{' initializer_list ','? '}'
			|'{' '}'
			;

/* class */




/* cpp  preprocessing */







/* old lex definition
identifier_nondigit -> $1
| identifier identifier_nondigit -> $1
| identifier digit -> $1
;
*/
%%